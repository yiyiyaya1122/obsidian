# 🔍 今日概览

**TODO**
- [x] `merge_json`脚本验证
- [x] `VR-Infer区分`、`数据标注`、`HDF5切分`流程跑通
- [x]  `hdf5_viewer`代码熟悉、优化
- [x] `HDF5`格式熟悉
- [x] `Imitation Learning`熟悉
- [x]  `ROS2`安装
---

# ⏱️ 时间轴日志（9:00 - 22:00）

|    **时间段**    |               **事项记录**                | **问题记录** | **关键进展** |
| :-----------: | :-----------------------------------: | :------- | :------: |
| 09:00 - 10:00 |           `merge_json`脚本验证            |          |          |
| 10:00 - 11:00 |              `HDF5`格式熟悉               |          |          |
| 11:00 - 12:00 |         `hdf5_viewer`代码熟悉、优化          |          |          |
| 12:00 - 13:00 |              🍽️ 午餐 / 休息              |          |          |
| 13:00 - 14:00 |         `hdf5_viewer`代码熟悉、优化          |          |          |
| 14:00 - 15:00 |        `Imitation Learning`熟悉         |          |          |
| 15:00 - 16:00 | `ROS2`安装、熟悉<br>`Imitation Learning`熟悉 |          |          |
| 16:00 - 17:00 |         `hdf5_viewer`代码熟悉、优化          |          |          |
| 17:00 - 18:00 |                                       |          |          |
| 18:00 - 19:00 |              🍽️ 晚餐 / 休息              |          |          |
| 19:00 - 20:00 |                                       |          |          |
| 20:00 - 21:00 |                                       |          |          |
| 21:00 - 22:00 |                                       |          |          |

---
# 📥 今日充电

## `HDF5`数据结构

**[HDF5](https://link.zhihu.com/?target=https%3A//www.hdfgroup.org/solutions/hdf5/)** (Hierarchical Data Format) 由美国**伊利诺伊大学厄巴纳-香槟分校** **[UIUC](https://link.zhihu.com/?target=http%3A//www.illinois.edu/)** (University of Illinois at Urbana-Champaign) 开发，是一种常见的跨平台数据储存文件，可以存储不同类型的图像和数码数据，并且可以在不同类型的机器上传输，同时还有统一处理这种文件格式的函数库。
### `HDF5` 结构

**HDF5** 文件结构中有 **2 primary objects:** **[Groups](https://zhida.zhihu.com/search?content_id=111273919&content_type=Article&match_order=1&q=Groups&zhida_source=entity)** 和 **[Datasets](https://zhida.zhihu.com/search?content_id=111273919&content_type=Article&match_order=1&q=Datasets&zhida_source=entity)**
- **Groups** 就类似于文件夹，每个 **HDF5** 文件其实就是**根目录** (root) **group** `'/'`。
- **Datasets** 类似于 **[NumPy](https://link.zhihu.com/?target=https%3A//numpy.org/)** 中的数组 array 。

每个 `dataset` 可以分成两部分: **原始数据 (raw) data values** 和 **元数据 metadata** (a set of data that describes and gives information about other data => raw data)。

```cpp
+-- Dataset
|   +-- (Raw) Data Values (eg: a 4 x 5 x 6 matrix)
|   +-- Metadata
|   |   +-- Dataspace (eg: Rank = 3, Dimensions = {4, 5, 6})
|   |   +-- Datatype (eg: Integer)
|   |   +-- Properties (eg: Chuncked, Compressed)
|   |   +-- Attributes (eg: attr1 = 32.4, attr2 = "hello", ...)
|
```

从上面的结构中可以看出：
- **Dataspace** 给出原始数据的**秩** (Rank) 和**维度** (dimension)
- **Datatype** 给出数据类型
- **Properties** 说明该 dataset 的**分块储存**以及**压缩**情况
	- **Chunked**: Better access time for subsets; extendible
	- **Chunked & Compressed**: Improves storage efficiency, transmission speed
- **Attributes** 为该 dataset 的其他自定义属性

```cpp
+-- /
|   +-- group_1
|   |   +-- dataset_1_1
|   |   |   +-- attribute_1_1_1
|   |   |   +-- attribute_1_1_2
|   |   |   +-- ...
|   |   |
|   |   +-- dataset_1_2
|   |   |   +-- attribute_1_2_1
|   |   |   +-- attribute_1_2_2
|   |   |   +-- ...
|   |   |
|   |   +-- ...
|   |
|   +-- group_2
|   |   +-- dataset_2_1
|   |   |   +-- attribute_2_1_1
|   |   |   +-- attribute_2_1_2
|   |   |   +-- ...
|   |   |
|   |   +-- dataset_2_2
|   |   |   +-- attribute_2_2_1
|   |   |   +-- attribute_2_2_2
|   |   |   +-- ...
|   |   |
|   |   +-- ...
|   |
|   +-- ...
|
```

### `VLA`中的`HDF5`

```cpp
ROOT_HDF5_FILE
├── 📊 数据集 (Datasets)
│   ├── collection_frequency  ⚡
│   │   └── 形状: 标量 | 类型: float32
│   ├── compress_len 📏
│   │   └── 形状: 3×4359 | 类型: int64
│   └── ctrlmode 🎮
│       └── 形状: 4359×1 | 类型: int32
│
├── 👁️ 观测数据组 (observations)
│   └── 图像组 (images) 📸
│       ├── cam_high 🎥 (高位相机)
│       │   └── 形状: 4359×33923 | 类型: uint8
│       ├── cam_left_wrist 👈 (左手腕相机)
│       │   └── 形状: 4359×38958 | 类型: uint8
│       └── cam_right_wrist 👉 (右手腕相机)
│           └── 形状: 4359×38311 | 类型: uint8
│
└── 🤖 状态数据组 (state)
    └── 关节数据组 (joint)
        ├── 当前关节状态 (joint_cur)
        │   ├── left 🤲 (左臂)
        │   │   └── 形状: 4359×7 | 类型: float64
        │   └── right 🤲 (右臂)
        │       └── 形状: 4359×7 | 类型: float64
        └── 目标关节位置 (joint_position)
            ├── left 🎯 (左臂)
            │   └── 形状: 4359×7 | 类型: float64
            └── right 🎯 (右臂)
                └── 形状: 4359×7 | 类型: float64

```

- `images`组的`4359×33923`，`4359`是帧数，`33923`是字节数
- `state`组的`4359×7`，`4359`是帧数，`7`是`7`个关节自由度

### 机械臂`7-DOF`详解

```cpp
┌─ 1. 肩部俯仰 (Shoulder Pitch)
│  - 作用：手臂上下摆动
│  - 运动平面：矢状面
│  - 示例：抬手、放低手臂
│
├─ 2. 肩部偏航 (Shoulder Yaw)  
│  - 作用：手臂左右摆动
│  - 运动平面：水平面
│  - 示例：手臂横向展开
│
├─ 3. 肩部翻滚 (Shoulder Roll)
│  - 作用：手臂绕自身轴线旋转
│  - 运动平面：轴向旋转
│  - 示例：转动手臂
│
├─ 4. 肘部俯仰 (Elbow Pitch)
│  - 作用：弯曲或伸直肘部
│  - 运动平面：矢状面
│  - 示例：屈肘动作     
│
├─ 5. 腕部俯仰 (Wrist Pitch)
│  - 作用：手腕上下摆动
│  - 运动平面：矢状面
│  - 示例：点头式手腕运动
│
├─ 6. 腕部偏航 (Wrist Yaw)
│  - 作用：手腕左右摆动  
│  - 运动平面：水平面
│  - 示例：摇头式手腕运动
│
└─ 7. 腕部翻滚 (Wrist Roll)
   - 作用：手腕绕自身轴线旋转
   - 运动平面：轴向旋转
   - 示例：转动手腕

```

```cpp
每个时间点的7个关节值示例
时间点_i = [肩俯仰, 肩偏航, 肩翻滚, 肘俯仰, 腕俯仰, 腕偏航, 腕翻滚]

eg：
示例数据 = [0.12, -0.45, 1.23, 0.67, -0.89, 0.34, -0.56]  # 单位：弧度
```

### References
- [HDF5 数据文件简介](https://zhuanlan.zhihu.com/p/104145585)



## `hdf5_viewer`代码熟悉、优化

`_decode_compressed_image`方法在提取有效帧之后再进行`imdecode`，可有效

```python
# 提取有效的压缩数据（去除填充）
valid_compressed_data = compressed_data[:compressed_length]

# 使用OpenCV解码JPEG图像
decoded_image = cv2.imdecode(valid_compressed_data, cv2.IMREAD_COLOR)

```

## `Python`语法

### 魔术方法
在`Python中`，像`__exit__`这样前后都有双下划线的方法被称为**魔术方法**（`Magic Methods`）或**双下方法**（`Dunder Methods`）。魔术方法是`Python`中具有特殊含义的方法，它们会在特定的时机被自动调用。

### `Protected Method`和`Private Method`

```python
class MyClass:
    def __init__(self):
        self.public_attr = "公开属性"
        self._protected_attr = "受保护属性"
    
    def public_method(self):
        """公开方法 - 可以被外部直接调用"""
        return "这是公开方法"
    
    def _protected_method(self):
        """受保护方法 - 建议仅在类内部和子类中使用"""
        return "这是受保护方法"
    
    def __private_method(self):
        """私有方法 - 双下划线，名称修饰"""
        return "这是私有方法"
```

## `Imitation Learning`熟悉
### Introduction

**模仿学习**（`Imitation Learning`）—— 从专家示例中学习 —— 是一种让智能体（机器人）像人类专家一样能够进行智能决策的方法。普遍认为模仿学习有两大类算法：**行为克隆** （`Behavioral Cloning`）和**对抗式模仿学习**（`Adversarial Imitation Learning`）。其中，**行为克隆**算法尝试最小化智能体策略和专家策略的动作差异，把模仿学习任务归约到常见的回归或者分类任务。而**对抗式模仿学习**算法则是通过逆强化学习 （`Inverse Reinforcement Learning`）来构建一个对抗的奖赏函数，然后最大化这个奖赏函数去模仿专家行为。

### Challenge
- **Covariate Shift**：**专家状态**与**智能体状态**之间**分布不匹配**
- **Compounding Error**：**智能体**在执行**长序列任务**时，**每一步的微小误差会不断叠加**，最终导致整体行为严重偏离**专家轨迹**
![[Pasted image 20251020142438.png]]
### Strategies
- `Dataset Aggregation`
### References
- [模仿学习简洁教程(南京大学)](https://www.lamda.nju.edu.cn/xut/Imitation_Learning.pdf)
- [Imitation Learning(斯坦福)](https://web.stanford.edu/class/cs237b/pdfs/lecture/lecture_10111213.pdf)

## `ROS2`安装学习

1.**ROS 1 与 ROS 2 核心区别对比**

| 特性/方面      | ROS 1 (Noetic及之前)       | ROS 2 (Humble, Foxy, Iron等)            | 区别解读                                                                                                  |
| :--------- | :---------------------- | :------------------------------------- | :---------------------------------------------------------------------------------------------------- |
| **核心架构**   | **主节点（Master）中心化**      | **去中心化，基于DDS**                         | **这是最根本的区别。** ROS 1 严重依赖一个主节点来管理节点发现和通信，主节点崩溃则整个系统瘫痪。ROS 2 使用 DDS 作为底层通信中间件，实现了真正的分布式、去中心化通信，无单点故障。   |
| **通信模型**   | 基于 TCPROS/UDPROS 的自定义协议 | **基于 DDS (Data Distribution Service)** | DDS 是一个工业级的通信标准，提供了丰富的服务质量策略，使得 ROS 2 的通信更加可靠、灵活和强大。                                                  |
| **实时性**    | 很差                      | **优秀**                                 | ROS 1 不是为实时系统设计的。ROS 2 利用 DDS 的实时特性，并且重构了底层代码，可以很好地运行在实时操作系统上，满足工业控制等对实时性要求高的场景。                      |
| **网络支持**   | 原生不支持 NAT 和复杂网络         | **原生支持**                               | ROS 1 的通信严重依赖组播，在跨路由器、跨VLAN、有防火墙的复杂网络环境中配置非常困难。ROS 2 的 DDS 天生支持这些场景。                                  |
| **平台支持**   | 主要支持 Ubuntu             | **跨平台**                                | ROS 2 官方支持 Windows, macOS, Linux 和实时操作系统，极大地扩展了其应用范围。                                                 |
| **产品化与安全** | 较弱                      | **强**                                  | ROS 2 在设计之初就考虑了产品化需求，引入了**生命周期管理**（安全地启动、关闭节点）和对**安全通信**（如 DDS-Security）的支持，这对于自动驾驶、医疗机器人等安全关键领域至关重要。 |
| **进程内通信**  | 有限                      | **高效**                                 | ROS 2 支持同一进程内的多个节点通过“零拷贝”方式进行高效通信，大大降低了延迟和CPU占用，这对于需要高性能计算的应用非常有利。                                    |
| **构建系统**   | `catkin`                | `ament` (基于CMake)                      | `ament` 是 `catkin` 的进化版，提供了更清晰的依赖管理和工具链。                                                              |
| **质量服务策略** | 固定、有限                   | **丰富、可配置**                             | ROS 2 通过 DDS 提供了多种 QoS 策略，开发者可以根据需要配置通信的可靠性（最佳努力 vs 可靠）、持久性（保留最后一条消息）、截止时间等。这是 ROS 1 无法做到的。           |

2.**`ROS2`安装**
使用小鱼一键安装`ros2`脚本

3.**`ROS2`测试**
```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

4.**安装`colcon`构建工具**
```
sudo apt install python3-colcon-common-extensions
```

**References**:
- [Ubuntu安装ROS(2) —— 安装ROS2 humble(最新、超详细图文教程，包含配置rosdep)](https://blog.csdn.net/weixin_55944949/article/details/140373710)
- [测试ROS2](https://zhangzhiwei-zzw.github.io/ROS2%E5%AD%A6%E4%B9%A0/ROS2/chapter1/12-ros2an-zhuang/122-ce-shi-ros2/)




---

# 🧠 总结与反思

| 项目           | 内容                         |
|----------------|------------------------------|
| 🎯 是否达成目标 |                              |
| 🧱 碰到的困难   |                              |
| 🧰 解决方法     |                              |
| ✨ 明日优化点   |                              |
| 💭 自我感受     |                              |

---

# 📌 明日计划

- [ ] 
- [ ] 
- [ ] 
